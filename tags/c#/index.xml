<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C# on frikyfriky11</title><link>https://frikyfriky11.github.io/tags/c%23/</link><description>Recent content in C# on frikyfriky11</description><generator>Hugo</generator><language>en</language><lastBuildDate>Thu, 11 Jan 2024 12:35:17 +0100</lastBuildDate><atom:link href="https://frikyfriky11.github.io/tags/c%23/index.xml" rel="self" type="application/rss+xml"/><item><title>Typed injectable API clients with RestSharp</title><link>https://frikyfriky11.github.io/posts/typed-injectable-api-clients-with-restsharp/</link><pubDate>Thu, 11 Jan 2024 12:35:17 +0100</pubDate><guid>https://frikyfriky11.github.io/posts/typed-injectable-api-clients-with-restsharp/</guid><description>&lt;h2 id="preface">
 Preface
 &lt;a class="heading-link" href="#preface">
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading">&lt;/i>
 &lt;span class="sr-only">Link to heading&lt;/span>
 &lt;/a>
&lt;/h2>
&lt;p>In my day-to-day work, I often find myself needing to access external data via an external API.&lt;/p>
&lt;p>If you&amp;rsquo;re using C# and recent versions of .NET (both ASP.NET Core and Worker flavors) and need to do something similar, you may find useful to create a client for the external API and inject it whenever you need it via Dependency Injection.&lt;/p>
&lt;p>Writing everything from scratch can lead to a lot of boilerplate. Luckily, we can use the help of a great library called &lt;a href="https://restsharp.dev/" class="external-link" target="_blank" rel="noopener">RestSharp&lt;/a> (&lt;a href="https://github.com/restsharp/RestSharp" class="external-link" target="_blank" rel="noopener">GitHub&lt;/a>).&lt;/p></description></item><item><title>AutoMapper between classes and records</title><link>https://frikyfriky11.github.io/posts/automapper-between-classes-and-records/</link><pubDate>Sun, 04 Jun 2023 22:46:38 +0200</pubDate><guid>https://frikyfriky11.github.io/posts/automapper-between-classes-and-records/</guid><description>&lt;p>Mapping objects between different classes or data structures is a common task in software development. It allows us to transform data from one representation to another. &lt;a href="https://automapper.org/" class="external-link" target="_blank" rel="noopener">AutoMapper&lt;/a> is a powerful library that simplifies this process by automatically mapping properties based on naming conventions. However, when working with &lt;a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/record" class="external-link" target="_blank" rel="noopener">records&lt;/a>, there are some specific considerations to keep in mind to ensure seamless mapping. In this blog post, I will share an issue I encountered while using AutoMapper v12.0.1 to map properties between a class and a record, along with the solution I found to overcome it.&lt;/p></description></item><item><title>What is lowering and why should you care</title><link>https://frikyfriky11.github.io/posts/what-is-lowering-why-should-you-care/</link><pubDate>Wed, 14 Sep 2022 06:57:07 +0200</pubDate><guid>https://frikyfriky11.github.io/posts/what-is-lowering-why-should-you-care/</guid><description>&lt;p>Nowadays we&amp;rsquo;re all writing highly understandable code (&lt;em>or at least that&amp;rsquo;s what I&amp;rsquo;m telling my coworkers!&lt;/em>) in high level languages, almost completely forgetting what those pieces of code are translated to once they are compiled or interpreted.&lt;/p>
&lt;p>Back in the day, people used to punch holes into cards to represent bits as instructions for the CPU, then they invented low level languages, then high level languages, and now we even have high level languages that transpile to other high level languages instead of compiling them (think of TypeScript to JavaScript for example).&lt;/p></description></item></channel></rss>